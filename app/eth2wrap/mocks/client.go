// Copyright Â© 2022-2024 Obol Labs Inc. Licensed under the terms of a Business Source License 1.1

// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
	api "github.com/attestantio/go-eth2-client/api"
	altair "github.com/attestantio/go-eth2-client/spec/altair"

	context "context"

	eth2exp "github.com/obolnetwork/charon/eth2util/eth2exp"

	eth2wrap "github.com/obolnetwork/charon/app/eth2wrap"

	mock "github.com/stretchr/testify/mock"

	phase0 "github.com/attestantio/go-eth2-client/spec/phase0"

	spec "github.com/attestantio/go-eth2-client/spec"

	time "time"

	v1 "github.com/attestantio/go-eth2-client/api/v1"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// ActiveValidators provides a mock function with given fields: _a0
func (_m *Client) ActiveValidators(_a0 context.Context) (eth2wrap.ActiveValidators, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ActiveValidators")
	}

	var r0 eth2wrap.ActiveValidators
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (eth2wrap.ActiveValidators, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) eth2wrap.ActiveValidators); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(eth2wrap.ActiveValidators)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Address provides a mock function with given fields:
func (_m *Client) Address() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AggregateAttestation provides a mock function with given fields: ctx, opts
func (_m *Client) AggregateAttestation(ctx context.Context, opts *api.AggregateAttestationOpts) (*api.Response[*phase0.Attestation], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for AggregateAttestation")
	}

	var r0 *api.Response[*phase0.Attestation]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.AggregateAttestationOpts) (*api.Response[*phase0.Attestation], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.AggregateAttestationOpts) *api.Response[*phase0.Attestation]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*phase0.Attestation])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.AggregateAttestationOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AggregateBeaconCommitteeSelections provides a mock function with given fields: ctx, partialSelections
func (_m *Client) AggregateBeaconCommitteeSelections(ctx context.Context, partialSelections []*eth2exp.BeaconCommitteeSelection) ([]*eth2exp.BeaconCommitteeSelection, error) {
	ret := _m.Called(ctx, partialSelections)

	if len(ret) == 0 {
		panic("no return value specified for AggregateBeaconCommitteeSelections")
	}

	var r0 []*eth2exp.BeaconCommitteeSelection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*eth2exp.BeaconCommitteeSelection) ([]*eth2exp.BeaconCommitteeSelection, error)); ok {
		return rf(ctx, partialSelections)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*eth2exp.BeaconCommitteeSelection) []*eth2exp.BeaconCommitteeSelection); ok {
		r0 = rf(ctx, partialSelections)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*eth2exp.BeaconCommitteeSelection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*eth2exp.BeaconCommitteeSelection) error); ok {
		r1 = rf(ctx, partialSelections)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AggregateSyncCommitteeSelections provides a mock function with given fields: ctx, partialSelections
func (_m *Client) AggregateSyncCommitteeSelections(ctx context.Context, partialSelections []*eth2exp.SyncCommitteeSelection) ([]*eth2exp.SyncCommitteeSelection, error) {
	ret := _m.Called(ctx, partialSelections)

	if len(ret) == 0 {
		panic("no return value specified for AggregateSyncCommitteeSelections")
	}

	var r0 []*eth2exp.SyncCommitteeSelection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []*eth2exp.SyncCommitteeSelection) ([]*eth2exp.SyncCommitteeSelection, error)); ok {
		return rf(ctx, partialSelections)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []*eth2exp.SyncCommitteeSelection) []*eth2exp.SyncCommitteeSelection); ok {
		r0 = rf(ctx, partialSelections)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*eth2exp.SyncCommitteeSelection)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []*eth2exp.SyncCommitteeSelection) error); ok {
		r1 = rf(ctx, partialSelections)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttestationData provides a mock function with given fields: ctx, opts
func (_m *Client) AttestationData(ctx context.Context, opts *api.AttestationDataOpts) (*api.Response[*phase0.AttestationData], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for AttestationData")
	}

	var r0 *api.Response[*phase0.AttestationData]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.AttestationDataOpts) (*api.Response[*phase0.AttestationData], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.AttestationDataOpts) *api.Response[*phase0.AttestationData]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*phase0.AttestationData])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.AttestationDataOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttesterDuties provides a mock function with given fields: ctx, opts
func (_m *Client) AttesterDuties(ctx context.Context, opts *api.AttesterDutiesOpts) (*api.Response[[]*v1.AttesterDuty], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for AttesterDuties")
	}

	var r0 *api.Response[[]*v1.AttesterDuty]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.AttesterDutiesOpts) (*api.Response[[]*v1.AttesterDuty], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.AttesterDutiesOpts) *api.Response[[]*v1.AttesterDuty]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[[]*v1.AttesterDuty])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.AttesterDutiesOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockRoot provides a mock function with given fields: ctx, opts
func (_m *Client) BeaconBlockRoot(ctx context.Context, opts *api.BeaconBlockRootOpts) (*api.Response[*phase0.Root], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for BeaconBlockRoot")
	}

	var r0 *api.Response[*phase0.Root]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.BeaconBlockRootOpts) (*api.Response[*phase0.Root], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.BeaconBlockRootOpts) *api.Response[*phase0.Root]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*phase0.Root])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.BeaconBlockRootOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlockAttestations provides a mock function with given fields: ctx, stateID
func (_m *Client) BlockAttestations(ctx context.Context, stateID string) ([]*phase0.Attestation, error) {
	ret := _m.Called(ctx, stateID)

	if len(ret) == 0 {
		panic("no return value specified for BlockAttestations")
	}

	var r0 []*phase0.Attestation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*phase0.Attestation, error)); ok {
		return rf(ctx, stateID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*phase0.Attestation); ok {
		r0 = rf(ctx, stateID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*phase0.Attestation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, stateID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DepositContract provides a mock function with given fields: ctx, opts
func (_m *Client) DepositContract(ctx context.Context, opts *api.DepositContractOpts) (*api.Response[*v1.DepositContract], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for DepositContract")
	}

	var r0 *api.Response[*v1.DepositContract]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.DepositContractOpts) (*api.Response[*v1.DepositContract], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.DepositContractOpts) *api.Response[*v1.DepositContract]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*v1.DepositContract])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.DepositContractOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Domain provides a mock function with given fields: ctx, domainType, epoch
func (_m *Client) Domain(ctx context.Context, domainType phase0.DomainType, epoch phase0.Epoch) (phase0.Domain, error) {
	ret := _m.Called(ctx, domainType, epoch)

	if len(ret) == 0 {
		panic("no return value specified for Domain")
	}

	var r0 phase0.Domain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType, phase0.Epoch) (phase0.Domain, error)); ok {
		return rf(ctx, domainType, epoch)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType, phase0.Epoch) phase0.Domain); ok {
		r0 = rf(ctx, domainType, epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(phase0.Domain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.DomainType, phase0.Epoch) error); ok {
		r1 = rf(ctx, domainType, epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Fork provides a mock function with given fields: ctx, opts
func (_m *Client) Fork(ctx context.Context, opts *api.ForkOpts) (*api.Response[*phase0.Fork], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Fork")
	}

	var r0 *api.Response[*phase0.Fork]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ForkOpts) (*api.Response[*phase0.Fork], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ForkOpts) *api.Response[*phase0.Fork]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*phase0.Fork])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ForkOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForkSchedule provides a mock function with given fields: ctx, opts
func (_m *Client) ForkSchedule(ctx context.Context, opts *api.ForkScheduleOpts) (*api.Response[[]*phase0.Fork], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ForkSchedule")
	}

	var r0 *api.Response[[]*phase0.Fork]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ForkScheduleOpts) (*api.Response[[]*phase0.Fork], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ForkScheduleOpts) *api.Response[[]*phase0.Fork]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[[]*phase0.Fork])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ForkScheduleOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Genesis provides a mock function with given fields: ctx, opts
func (_m *Client) Genesis(ctx context.Context, opts *api.GenesisOpts) (*api.Response[*v1.Genesis], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Genesis")
	}

	var r0 *api.Response[*v1.Genesis]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.GenesisOpts) (*api.Response[*v1.Genesis], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.GenesisOpts) *api.Response[*v1.Genesis]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*v1.Genesis])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.GenesisOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenesisDomain provides a mock function with given fields: ctx, domainType
func (_m *Client) GenesisDomain(ctx context.Context, domainType phase0.DomainType) (phase0.Domain, error) {
	ret := _m.Called(ctx, domainType)

	if len(ret) == 0 {
		panic("no return value specified for GenesisDomain")
	}

	var r0 phase0.Domain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType) (phase0.Domain, error)); ok {
		return rf(ctx, domainType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType) phase0.Domain); ok {
		r0 = rf(ctx, domainType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(phase0.Domain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.DomainType) error); ok {
		r1 = rf(ctx, domainType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenesisTime provides a mock function with given fields: ctx
func (_m *Client) GenesisTime(ctx context.Context) (time.Time, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GenesisTime")
	}

	var r0 time.Time
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (time.Time, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsActive provides a mock function with given fields:
func (_m *Client) IsActive() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsActive")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsSynced provides a mock function with given fields:
func (_m *Client) IsSynced() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSynced")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Client) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// NodePeerCount provides a mock function with given fields: ctx
func (_m *Client) NodePeerCount(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for NodePeerCount")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeSyncing provides a mock function with given fields: ctx, opts
func (_m *Client) NodeSyncing(ctx context.Context, opts *api.NodeSyncingOpts) (*api.Response[*v1.SyncState], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for NodeSyncing")
	}

	var r0 *api.Response[*v1.SyncState]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.NodeSyncingOpts) (*api.Response[*v1.SyncState], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.NodeSyncingOpts) *api.Response[*v1.SyncState]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*v1.SyncState])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.NodeSyncingOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeVersion provides a mock function with given fields: ctx, opts
func (_m *Client) NodeVersion(ctx context.Context, opts *api.NodeVersionOpts) (*api.Response[string], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for NodeVersion")
	}

	var r0 *api.Response[string]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.NodeVersionOpts) (*api.Response[string], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.NodeVersionOpts) *api.Response[string]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[string])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.NodeVersionOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Proposal provides a mock function with given fields: ctx, opts
func (_m *Client) Proposal(ctx context.Context, opts *api.ProposalOpts) (*api.Response[*api.VersionedProposal], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Proposal")
	}

	var r0 *api.Response[*api.VersionedProposal]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ProposalOpts) (*api.Response[*api.VersionedProposal], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ProposalOpts) *api.Response[*api.VersionedProposal]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*api.VersionedProposal])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ProposalOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProposerConfig provides a mock function with given fields: ctx
func (_m *Client) ProposerConfig(ctx context.Context) (*eth2exp.ProposerConfigResponse, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ProposerConfig")
	}

	var r0 *eth2exp.ProposerConfigResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*eth2exp.ProposerConfigResponse, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *eth2exp.ProposerConfigResponse); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*eth2exp.ProposerConfigResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProposerDuties provides a mock function with given fields: ctx, opts
func (_m *Client) ProposerDuties(ctx context.Context, opts *api.ProposerDutiesOpts) (*api.Response[[]*v1.ProposerDuty], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for ProposerDuties")
	}

	var r0 *api.Response[[]*v1.ProposerDuty]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ProposerDutiesOpts) (*api.Response[[]*v1.ProposerDuty], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ProposerDutiesOpts) *api.Response[[]*v1.ProposerDuty]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[[]*v1.ProposerDuty])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ProposerDutiesOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetForkVersion provides a mock function with given fields: forkVersion
func (_m *Client) SetForkVersion(forkVersion [4]byte) {
	_m.Called(forkVersion)
}

// SetValidatorCache provides a mock function with given fields: _a0
func (_m *Client) SetValidatorCache(_a0 func(context.Context) (eth2wrap.ActiveValidators, error)) {
	_m.Called(_a0)
}

// SignedBeaconBlock provides a mock function with given fields: ctx, opts
func (_m *Client) SignedBeaconBlock(ctx context.Context, opts *api.SignedBeaconBlockOpts) (*api.Response[*spec.VersionedSignedBeaconBlock], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for SignedBeaconBlock")
	}

	var r0 *api.Response[*spec.VersionedSignedBeaconBlock]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SignedBeaconBlockOpts) (*api.Response[*spec.VersionedSignedBeaconBlock], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.SignedBeaconBlockOpts) *api.Response[*spec.VersionedSignedBeaconBlock]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*spec.VersionedSignedBeaconBlock])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.SignedBeaconBlockOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SlotDuration provides a mock function with given fields: ctx
func (_m *Client) SlotDuration(ctx context.Context) (time.Duration, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SlotDuration")
	}

	var r0 time.Duration
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (time.Duration, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) time.Duration); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SlotsPerEpoch provides a mock function with given fields: ctx
func (_m *Client) SlotsPerEpoch(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for SlotsPerEpoch")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Spec provides a mock function with given fields: ctx, opts
func (_m *Client) Spec(ctx context.Context, opts *api.SpecOpts) (*api.Response[map[string]interface{}], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Spec")
	}

	var r0 *api.Response[map[string]interface{}]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SpecOpts) (*api.Response[map[string]interface{}], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.SpecOpts) *api.Response[map[string]interface{}]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[map[string]interface{}])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.SpecOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitAggregateAttestations provides a mock function with given fields: ctx, aggregateAndProofs
func (_m *Client) SubmitAggregateAttestations(ctx context.Context, aggregateAndProofs []*phase0.SignedAggregateAndProof) error {
	ret := _m.Called(ctx, aggregateAndProofs)

	if len(ret) == 0 {
		panic("no return value specified for SubmitAggregateAttestations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.SignedAggregateAndProof) error); ok {
		r0 = rf(ctx, aggregateAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitAttestations provides a mock function with given fields: ctx, attestations
func (_m *Client) SubmitAttestations(ctx context.Context, attestations []*phase0.Attestation) error {
	ret := _m.Called(ctx, attestations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitAttestations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.Attestation) error); ok {
		r0 = rf(ctx, attestations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBeaconCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitBeaconCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.BeaconCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	if len(ret) == 0 {
		panic("no return value specified for SubmitBeaconCommitteeSubscriptions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.BeaconCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBlindedProposal provides a mock function with given fields: ctx, opts
func (_m *Client) SubmitBlindedProposal(ctx context.Context, opts *api.SubmitBlindedProposalOpts) error {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for SubmitBlindedProposal")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SubmitBlindedProposalOpts) error); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitProposal provides a mock function with given fields: ctx, opts
func (_m *Client) SubmitProposal(ctx context.Context, opts *api.SubmitProposalOpts) error {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for SubmitProposal")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SubmitProposalOpts) error); ok {
		r0 = rf(ctx, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitProposalPreparations provides a mock function with given fields: ctx, preparations
func (_m *Client) SubmitProposalPreparations(ctx context.Context, preparations []*v1.ProposalPreparation) error {
	ret := _m.Called(ctx, preparations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitProposalPreparations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.ProposalPreparation) error); ok {
		r0 = rf(ctx, preparations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeContributions provides a mock function with given fields: ctx, contributionAndProofs
func (_m *Client) SubmitSyncCommitteeContributions(ctx context.Context, contributionAndProofs []*altair.SignedContributionAndProof) error {
	ret := _m.Called(ctx, contributionAndProofs)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeContributions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SignedContributionAndProof) error); ok {
		r0 = rf(ctx, contributionAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeMessages provides a mock function with given fields: ctx, messages
func (_m *Client) SubmitSyncCommitteeMessages(ctx context.Context, messages []*altair.SyncCommitteeMessage) error {
	ret := _m.Called(ctx, messages)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SyncCommitteeMessage) error); ok {
		r0 = rf(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitSyncCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.SyncCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeSubscriptions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.SyncCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitValidatorRegistrations provides a mock function with given fields: ctx, registrations
func (_m *Client) SubmitValidatorRegistrations(ctx context.Context, registrations []*api.VersionedSignedValidatorRegistration) error {
	ret := _m.Called(ctx, registrations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitValidatorRegistrations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*api.VersionedSignedValidatorRegistration) error); ok {
		r0 = rf(ctx, registrations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitVoluntaryExit provides a mock function with given fields: ctx, voluntaryExit
func (_m *Client) SubmitVoluntaryExit(ctx context.Context, voluntaryExit *phase0.SignedVoluntaryExit) error {
	ret := _m.Called(ctx, voluntaryExit)

	if len(ret) == 0 {
		panic("no return value specified for SubmitVoluntaryExit")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *phase0.SignedVoluntaryExit) error); ok {
		r0 = rf(ctx, voluntaryExit)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncCommitteeContribution provides a mock function with given fields: ctx, opts
func (_m *Client) SyncCommitteeContribution(ctx context.Context, opts *api.SyncCommitteeContributionOpts) (*api.Response[*altair.SyncCommitteeContribution], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for SyncCommitteeContribution")
	}

	var r0 *api.Response[*altair.SyncCommitteeContribution]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SyncCommitteeContributionOpts) (*api.Response[*altair.SyncCommitteeContribution], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.SyncCommitteeContributionOpts) *api.Response[*altair.SyncCommitteeContribution]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[*altair.SyncCommitteeContribution])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.SyncCommitteeContributionOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCommitteeDuties provides a mock function with given fields: ctx, opts
func (_m *Client) SyncCommitteeDuties(ctx context.Context, opts *api.SyncCommitteeDutiesOpts) (*api.Response[[]*v1.SyncCommitteeDuty], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for SyncCommitteeDuties")
	}

	var r0 *api.Response[[]*v1.SyncCommitteeDuty]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.SyncCommitteeDutiesOpts) (*api.Response[[]*v1.SyncCommitteeDuty], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.SyncCommitteeDutiesOpts) *api.Response[[]*v1.SyncCommitteeDuty]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[[]*v1.SyncCommitteeDuty])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.SyncCommitteeDutiesOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validators provides a mock function with given fields: ctx, opts
func (_m *Client) Validators(ctx context.Context, opts *api.ValidatorsOpts) (*api.Response[map[phase0.ValidatorIndex]*v1.Validator], error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Validators")
	}

	var r0 *api.Response[map[phase0.ValidatorIndex]*v1.Validator]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.ValidatorsOpts) (*api.Response[map[phase0.ValidatorIndex]*v1.Validator], error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *api.ValidatorsOpts) *api.Response[map[phase0.ValidatorIndex]*v1.Validator]); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.Response[map[phase0.ValidatorIndex]*v1.Validator])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *api.ValidatorsOpts) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
